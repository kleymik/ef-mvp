<!DOCTYPE html>
<meta charset="utf-8">
<style>
 body {  font: 10px sans-serif;}
 .axis path,
 .axis line {  fill: none;  stroke: #000;  shape-rendering: crispEdges;}
 .dot       {  stroke: #000; }
</style>

<body>
<script src="http://localhost:2345/3lib/d3.v3.js"></script>
<script src="http://localhost:2345/3lib/numeric-1.2.6.js"></script>
<script src="http://localhost:2345/lib/mvp.js"></script>
<script>

var margin = {top: 20, right: 20, bottom: 30, left: 40},
width  = 960 - margin.left - margin.right,
height = 500 - margin.top - margin.bottom;

var wghtScaling = 10.0;
var inputCorrMtx;
var corrMtx;
var assetCount = 0;

// some testing of the mvp.js functions
// test2x2();
// test3x3();

function gdata(x)  { return x.__data__[1] }                      // a common accessor pattern: return the underlying domain object from its associated d3 graphical element
function clamp(x)  { return Math.min(Math.max(x,  3), 97) }      // max & min threshold to dampen drift from rounding error
function forKey(x) { return Object.entries(x) }                  // c.f. python, get all (key & value)s out of a dict


d3.json("data/portfolioAssetsAndChracteristics_4.json",
      function(error, jData) {
         forKey(jData.pfData).forEach(([k,r]) => { if (r.pfMemb==1) { assetCount +=1 } });          // use element id "k" to get record info "r"
          
         inputCorrMtx = jData.corr.mtx;            
         corrMtx = Array(assetCount);                                                   // slice out assetCount X assetCount matrix from input Matrix
         for(i=0; i<assetCount; i++){
             corrMtx[i] = Array(assetCount);
             for(j=0; j<assetCount; j++){ corrMtx[i][j] = inputCorrMtx[i][j] }
         }

         // plot axes

         var color = d3.scale.category10();

         var svgc = d3.select("body").append("svg")                                     // svgc = svg Container
             .attr("width",  width  + margin.left + margin.right)
             .attr("height", height + margin.top  + margin.bottom)
             .append("g")
             .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

         var scalerX = d3.scale.linear().range([0, width]);
         scalerX.domain(d3.extent(forKey(jData.pfData), ([k,r]) => { return r.oneYrRisk })).nice();  // unpacking dict key-values into array for d3.extent()
         var xAxis = d3.svg.axis().scale(scalerX).orient("bottom");
         svgc.append("g").attr("class", "x axis")
             .attr("transform", "translate(0," + height + ")")
             .call(xAxis)
             .append("text")
             .attr("class", "label")
             .attr("x", width)
             .attr("y", -6)
             .style("text-anchor", "end")
             .text("1 Year Risk %");

         var scalerY = d3.scale.linear().range([height, 0]);
         scalerY.domain(d3.extent(forKey(jData.pfData), ([k,r]) => { return r.oneYrReturn })).nice(); //unpacking dict key-values into array for d3.extent          
         var yAxis = d3.svg.axis().scale(scalerY).orient("left");
         svgc.append("g").attr("class", "y axis")
             .call(yAxis)
             .append("text")
             .attr("class", "label")
             .attr("transform", "rotate(-90)")
             .attr("y", 6)
             .attr("dy", ".71em")
             .style("text-anchor", "end")
             .text("1 Year Return %");


         var circleDrag = d3.behavior.drag()                                                        // drag on a circle
             .on("drag", function(d, i) {
                 if (d[1].assetId!="p") {                                                            // can't stretch the 100% weight portfolio 
                     deltaWght = (d3.event.dx+d3.event.dy) / 4;
                     console.log("scatterPLot:d3.behavior.drag:deltaWght:"+deltaWght);
                     pfAssetElems = d3.selectAll("circle").filter(([k,r]) => {
                         return r.pfMemb==1 }) // get just the assets in portfolio, not other objects
                     numOtherAssets = pfAssetElems[0].length-1;                                      // downweight the non-selected assest equally
                     pfAssetElems[0].forEach(function(e) {                                           // update their data                 // 3% < weight < 97% to avoid numerical inaccuracy 
                         if (d[1].assetId==e.getAttribute("myid")) { gdata(e).assetWeight = clamp(gdata(e).assetWeight + deltaWght); }
                         else                                      { gdata(e).assetWeight = clamp(gdata(e).assetWeight - deltaWght/numOtherAssets); }  // downweight the rest in equal proportions
                     });
                                                                                                         
                     pfAssetElems.attr("r", ([k,r]) => { return Math.sqrt(r.assetWeight * wghtScaling)}) // update radii of all portfolio's assets

                     asstWghts = pfAssetElems[0].map(function(e) { return gdata(e).assetWeight/wghtScaling } );
                     asstRtns  = pfAssetElems[0].map(function(e) { return gdata(e).oneYrReturn             } );
                     asstRsks  = pfAssetElems[0].map(function(e) { return gdata(e).oneYrRisk               } );

                     rr = calcPfRiskEnRtn(corrMtx, asstRsks, asstRtns, asstWghts);                  // compute new total portfolio risk & return
                     pfData = gdata(d3.select('circle.p')[0][0]);                                   // get the total portfolio circle
                     pfData.oneYrRisk   = rr.rsk * wghtScaling;
                     pfData.oneYrReturn = rr.rtn * wghtScaling; 
                     d3.select('circle.p')                                                          // re-assert to trigger update
                         .attr("cx", ([k,r]) => { return scalerX(r.oneYrRisk)   })
                         .attr("cy", ([k,r]) => { return scalerY(r.oneYrReturn) });
                }
             });

          // SVG Graphical Circle Element: one circle for each asset + one for the whole portfolio that is the sum of the size of the portfolio's assets
          // scgc[0].g.children[2].circle.attributes.pfMemb
          svgc.selectAll(".dot")
             .data(forKey(jData.pfData))                                                            // document.querySelector("circle").__data__
             .enter().append('circle')                                                               // circle.each(function(d) { d.element = this; }) 
             .attr("pfMemb",  ([k,r]) => { return r.pfMemb                               })
             .attr("class",   ([k,r]) => { return r.assetId                              })
             .attr("myid",    ([k,r]) => { return r.assetId                              })
             .attr("r",       ([k,r]) => { return Math.sqrt(r.assetWeight * wghtScaling) })          // use sqrt so that circle area is proportional to weight
             .attr("cx",      ([k,r]) => { return scalerX(r.oneYrRisk)                   })
             .attr("cy",      ([k,r]) => { return scalerY(r.oneYrReturn)                 })
             .style("fill",   ([k,r]) => { return color(r.assetClass)                    })
             .style("stroke", "grey")
             .style("stroke-width", 2)
             .call(circleDrag);

         // Create and append hyperbolic line element into svg group
         // this will not change when the asset weights change
         // it will only change when the correlations change
         // The line SVG Path we draw
         // The data for our line
         // hyperbola: compute x-values (returns) from y-values (risk) input data (since there can be two y values for a given x)
         var lineData = calcPfRiskFromPfRtns(corrMtx,
                                   forKey(jData.pfData).filter(([k,r]) => { return r.pfMemb==1}).map(([k,r]) => { return r.oneYrReturn } ),
                                   forKey(jData.pfData).filter(([k,r]) => { return r.pfMemb==1}).map(([k,r]) => { return r.oneYrRisk   } ),
                                   [0.0, 0.1, 0.2, 0.3, 0.6, 0.9, 0.95, 0.97, 0.99, 1, 1.1, 2, 2.5, 3, 4, 5, 6, 7, 8]);
         var lineFunction = d3.svg.line()             // This is the accessor function we talked about above
             .x(function(d) { return scalerX(d.rsk) })
             .y(function(d) { return scalerY(d.rtn) })
             // .interpolate("cardinal").tension(0.8);  // linear basis
             .interpolate("monotone");  //linear basis          
         svgc.append("path")
             .attr("d", lineFunction(lineData))
             .attr("pfMemb",   0)
             .attr("class",   "frontier")             // search for this when using selectAll() d3.selectAll('path.frontier')  
             .attr("myid",    123456)
             .attr("lineData", lineData)              // the control points to get an svg "cardinal" to approximnate a hyperbola
             .attr("stroke", "blue")
             .attr("stroke-width", 1)
             .attr("fill", "none");         

         if (1==0) { // tbd triangle of correlations)
           // Create and append straightline element into svg group
          svgc.selectAll(".dot")
              .data(jData.corrTriang)                                                      // document.querySelector("circle").__data__
              .enter().append('line')                                                      // circle.each(function(d) { d.element = this; }) 
              .attr("pfMemb",  0)
              .attr("class",   "corr-line")
              .attr("myid",    function(d) { return (d.assetId)                            })
              .attr("x1",      function(d) { return scalerX(d.oneYrRisk)                   })
              .attr("y1",      function(d) { return scalerY(d.oneYrReturn)                 })
              .attr("x2",      function(d) { return scalerX(d.oneYrRisk)                   })
              .attr("y2",      function(d) { return scalerY(d.oneYrReturn)                 })
              .style("stroke", "grey")
              .style("stroke-width", 8)
              // .call(circleDrag);
          }          

         svgc.append("line")
             .attr("x1", 250)
             .attr("y1", 50)
             .attr("x2", 150)
             .attr("y2", 150)
             .attr("stroke", "gray")
             .attr("stroke-width", 8);
         //     .append("text");
         

         var legend = svgc.selectAll(".legend")                              // put legend in top right corner
             .data(color.domain())
             .enter().append("g")
             .attr("class", "legend")
             .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")" });
         legend.append("rect")
             .attr("x", width - 18)
             .attr("width",  18)
             .attr("height", 18)
             .style("fill", color);
         legend.append("text")
             .attr("x", width - 24)
             .attr("y", 9)
             .attr("dy", ".35em")
             .style("text-anchor", "end")
             .text(function(d) { return d; });
      }); 


</script>
