<!DOCTYPE html>
<meta charset="utf-8">
<style>
 body {  font: 10px sans-serif;}
 .axis path,
 .axis line {  fill: none;  stroke: #000;  shape-rendering: crispEdges;}
 .dot       {  stroke: #000; }
</style>

<body>
<script src="http://localhost:2345/3lib/d3.v3.js"></script>
<script src="http://localhost:2345/3lib/numeric-1.2.6.js"></script>
<script src="http://localhost:2345/lib/mvp.js"></script>
<script>

var margin = {top: 20, right: 20, bottom: 30, left: 40},
width  = 960 - margin.left - margin.right,
height = 500 - margin.top - margin.bottom;

var wghtScaling = 10.0;
var inputCorrMtx;
var asstDataTbl2;
var corrMtx;
var assetDataTbl;
var assetCount = 0;

// asset correlations matrix
d3.json("data/assetCorrsData.json",
        function(error, json) { inputCorrMtx = json.corr.mtx; }); // alert(json);

d3.json("data/assetRskRtns.json",
        function(error, json) { asstDataTbl2 = json.data; });     // alert(json);  

d3.tsv("data/scatterData4.tsv", 
       function(error, data) {
           data.forEach(function(d, i) {
               if (d.pfMemb==1) { assetCount +=1 };  // count up the number of assets in the portfolio to clip the correlation matrix
               d.oneYrReturn = +d.oneYrReturn;       // in percent        // alert(d.assetId)
               d.oneYrRisk   = +d.oneYrRisk;         // in percent
               d.assetWeight = +d.assetWeight;       // in perdec
           });
           assetDataTbl = data;                      // export data into enclosing scope
           
           // alert("Number of Assets="+assetCount); // slice out assetCount X assetCount matrix from input Matrix
           corrMtx = Array(assetCount);
           for(i=0; i<assetCount; i++){
               corrMtx[i] = Array(assetCount);
               for(j=0; j<assetCount; j++){ corrMtx[i][j] = inputCorrMtx[i][j]; }
           }

           // plot axes
           var x     = d3.scale.linear().range([0, width]);
           var xAxis = d3.svg.axis().scale(x).orient("bottom");
           x.domain(d3.extent(data, function(d) { return d.oneYrRisk; })).nice();
           
           var y     = d3.scale.linear().range([height, 0]);
           var yAxis = d3.svg.axis().scale(y).orient("left");
           y.domain(d3.extent(data, function(d) { return d.oneYrReturn; })).nice();
           
           var color = d3.scale.category10();
           
           var svgc = d3.select("body").append("svg")  // rename to svgc = svg Container
               .attr("width",  width  + margin.left + margin.right)
               .attr("height", height + margin.top  + margin.bottom)
               .append("g")
               .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
           
           svgc.append("g").attr("class", "x axis")
               .attr("transform", "translate(0," + height + ")")
               .call(xAxis)
               .append("text")
               .attr("class", "label")
               .attr("x", width)
               .attr("y", -6)
               .style("text-anchor", "end")
               .text("1 Year Risk %");
           
           svgc.append("g").attr("class", "y axis")
               .call(yAxis)
               .append("text")
               .attr("class", "label")
               .attr("transform", "rotate(-90)")
               .attr("y", 6)
               .attr("dy", ".71em")
               .style("text-anchor", "end")
               .text("1 Year Return %");
           
           // var hypb     = d3.scale.linear().range([height, 0]);
           // var hypbAxis = d3.svg.axis().scale(hypb).orient("right");
           // hypb.domain(d3.extent(data, function(d) { return d.oneYrReturn; })).nice();

           // svgc.append("g").attr("class", "mvp_hyperbola")
           //       .call(hypbAxis)
           //       .append("text")
           //       .attr("class", "label")
           //       .attr("transform", "rotate(-90)")
           //       .attr("y", 6)
           //       .attr("dy", ".71em")
           //       .style("text-anchor", "end")
           //       .text("mvp hyperbola");
           
           // var width = 500;
           // var height = 500;
           
           //Create svg group element
           // var g = svg.append("g").attr("transform", function(d, i) { return "translate(0,0)"; });
           
           // The data for our line
           // hyperbola: compute x-values (returns) from y-values input data (since there can be two y values for a given x)
           var sampleRtns = [{ "x": 0.01, "y": 0},
                             { "x": 0.02, "y": 0},
                             { "x": 0.03, "y": 0},
                             { "x": 0.04, "y": 0},
                             { "x": 0.05, "y": 0},
                             { "x": 0.06, "y": 0},
                             { "x": 0.07, "y": 0},
                             { "x": 0.08, "y": 0}];

           
           // Create and append straightline element into svg group
           svgc.append("line")
               .attr("x1", 250)
               .attr("y1", 50)
               .attr("x2", 150)
               .attr("y2", 150)
               .attr("stroke", "gray")
               .attr("stroke-width", 8);
           //     .append("text");
           
           //Ran it through the d3.svg.line() function with the accessor functions attached:
           
           // // Create and append ellipse element into group
           // var ellipse1 = g.append("ellipse")
           //                .attr("cx", 250)
           //                .attr("cy", 50)
           //                .attr("rx", 150)
           //                .attr("ry", 50)
           //                .append("text")
           
           // // Create and append text element into group
           // g.append("text")
           //  .attr("x", 150)
           //  .attr("y", 50)
           //  .attr("stroke", "#fff")
           //  .text("This is an ellipse!");                               
           
           // $.find("svg rect.aName")[0].__data__;
           // db1.filter(function(e) {return e.pfMemb==1})
           // d3.selectAll("circle").filter(function(e) {return e.pfMemb==1})
           
           var circleDrag = d3.behavior.drag()  // drag on a circle
               .on("drag", function(d,i) {
                   if (d.assetId!="p") {                                                              // can't stretch the 100% weight portfolio 
                       deltaWght = (d3.event.dx+d3.event.dy)/4;
                       console.log("scatterPLot:d3.behavior.drag:deltaWght:"+deltaWght);
                       pfAssetElems = d3.selectAll("circle").filter(function(e) {return e.pfMemb==1}) // get just the assets in portfolio, not other objects
                       numOtherAssets = pfAssetElems[0].length-1;                                     // downweight the non-selected assest equally
                       pfAssetElems[0].forEach(function(x) {                                          // update their data 
                           sameThing = (d.assetId==x.getAttribute("myid"));                           // sameThing = (x.__data__.assetId==x.getAttribute("myid")); 
                           if (sameThing) { 
                               newWght = x.__data__.assetWeight + deltaWght; 
                               x.__data__.assetWeight= Math.min(Math.max(newWght,  3), 97);           // 3% < weight < 97% to avoid numerical inaccuracy 
                           } else { 
                               newWght = x.__data__.assetWeight - deltaWght/numOtherAssets; 
                               x.__data__.assetWeight = Math.min(Math.max(newWght, 3), 97);           // 3% < weight < 97% to avoid numerical inaccuracy 
                           }  // down weight the rest equally
                       });
                       
                       pfAssetElems.attr("r", function(dd){ return Math.sqrt(dd.assetWeight * wghtScaling)}) // update their radii
                       
                       asstWghts = pfAssetElems[0].map(function(x) { return x.__data__.assetWeight/wghtScaling } );
                       asstRtns  = pfAssetElems[0].map(function(x) { return x.__data__.oneYrReturn             } );
                       asstRsks  = pfAssetElems[0].map(function(x) { return x.__data__.oneYrRisk               } );
                       
                       rr = calcPfRiskEnRtn(corrMtx, asstRsks, asstRtns, asstWghts);
                       
                       pfData = d3.select('circle.p')[0][0].__data__;                                 // get all the circles
                       pfData.oneYrRisk   = rr.rsk*wghtScaling;
                       pfData.oneYrReturn = rr.rtn*wghtScaling ;
                       d3.select('circle.p')                                                          // re-assert to trigger update
                           .attr("cx", function(e) { return x(e.oneYrRisk);   })
                           .attr("cy", function(e) { return y(e.oneYrReturn); });


                       pfFrontierPathElem = d3.selectAll("path.frontier")                              // get the hyperbola path graphical thingy
                       pfFrontierPathElem[0].forEach(function(x) {                                           // update their data
                           sv = calcPfRtnFromRisk(corrMtx, asstRsks, asstRtns, asstWghts, numAssts, sampleRtns)  
                           // now redraw the hyperbola
                           newWght = x.__data__.assetWeight + deltaWght; 
                           x.__data__.assetWeight= Math.min(Math.max(newWght,  3), 97);           // 3% < weight < 97% to avoid numerical inaccuracy 

                           d3.select('hypb.p')                                                            // re-assert to trigger update
                               .attr("cx", function(e) { return x(e.oneYrRisk);   })
                               .attr("cy", function(e) { return y(e.oneYrReturn); });
                       })
                   }

               });

           // SVG Graphical Element: circle: one circle for each asset + one for the whole portfolio that is the sum of the size
           // 
           svgc.selectAll(".dot")
               .data(data)                                                                       // document.querySelector("circle").__data__
               .enter().append('circle')                                                        //       circle.each(function(d) { d.element = this; }) 
               .attr("pfMemb",  function(d) { return (d.pfMemb);          })
               .attr("class",   function(d) { return (d.assetId);         })
               .attr("myid",    function(d) { return (d.assetId);         })
               .attr("r",       function(d) { return Math.sqrt(d.assetWeight * wghtScaling); })  // use sqrt so that circle area is proportional to weight
               .attr("cx",      function(d) { return x(d.oneYrRisk);      })
               .attr("cy",      function(d) { return y(d.oneYrReturn);    })
               .style("fill",   function(d) { return color(d.assetClass); })
               .style("stroke", "grey")
               .style("stroke-width", 2)
               .call(circleDrag);

           // Create and append hyperbolic line element into svg group
           //The line SVG Path we draw
           var lineData = [{ "x": 400, "y": 450},
                           { "x": 300, "y": 440},
                           { "x": 200, "y": 430},
                           { "x": 40,  "y": 400},
                           { "x": 200, "y": 270},
                           { "x": 300, "y": 200},
                           { "x": 400, "y": 100},
                           { "x": 500, "y": 0}];
           var lineFunction = d3.svg.line()             // This is the accessor function we talked about above
               .x(function(d) { return d.x; })
               .y(function(d) { return d.y; })
               .interpolate("cardinal");  //linear basis
           svgc.append("path")
               .attr("d", lineFunction(lineData))
               .attr("pfMemb",   0)
               .attr("class",   "frontier")             // search for this when using selectAll()
               .attr("myid",    123456)
               .attr("lineData", lineData)              // the control points to get an svg "cardinal" to approximnate a hyperbola
               .attr("stroke", "blue")
               .attr("stroke-width", 4)
               .attr("fill", "none");         
           
           // put legend in top right corner
           var legend = svgc.selectAll(".legend")
               .data(color.domain())
               .enter().append("g")
               .attr("class", "legend")
               .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });
           
           legend.append("rect")
               .attr("x", width - 18)
               .attr("width",  18)
               .attr("height", 18)
               .style("fill", color);
           
           legend.append("text")
               .attr("x", width - 24)
               .attr("y", 9)
               .attr("dy", ".35em")
               .style("text-anchor", "end")
               .text(function(d) { return d; });

   });

</script>
