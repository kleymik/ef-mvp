<!DOCTYPE html>
<meta charset="utf-8">
<style>
 body {  font: 10px sans-serif;}
 .axis path,
 .axis line {  fill: none;  stroke: #000;  shape-rendering: crispEdges;}
 .dot       {  stroke: #000; }
</style>

<body>
<script src="http://localhost:2345/3lib/d3.v3.min.js"></script>
<script src="http://localhost:2345/3lib/numeric-1.2.6.js"></script>
<script src="http://localhost:2345/lib/mvp.js"></script>
<script>

  var margin = {top: 20, right: 20, bottom: 30, left: 40},
      width  = 960 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;

  var wghtScaling = 10.0;
  var inputCorrMtx;
  var data2;
  var corrMtx;
  var assetDataTbl;
  var assetCount = 0;

  // asset correlations matrix
  d3.json("data/assetCorrsData.json", function(error, json) { inputCorrMtx = json.corr.mtx; }); // alert(json);
  d3.json("data/assetRskRtns.json",   function(error, json) { data2 = json.data; });            // alert(json);  
  d3.tsv("data/scatterData4.tsv", 
     function(error, data) {
      data.forEach(function(d,i) {
        if (d.pfMemb==1) { assetCount +=1 };   // count up the number of assets in the portfolio to clip the correlation matrix
        d.oneYrReturn = +d.oneYrReturn;        // in percent        // alert(d.assetId)
        d.oneYrRisk   = +d.oneYrRisk;          // in percent
        d.assetWeight = +d.assetWeight;        // in perdec
     });

    alert("Number of Assets="+assetCount);     // slice out assetCount X assetCount matrix from input Matrix
    corrMtx = Array(assetCount);
    for(i=0; i<assetCount; i++){
	corrMtx[i] = Array(assetCount);
	for(j=0; j<assetCount; j++){ corrMtx[i][j] = inputCorrMtx[i][j]; }
    }
    
    assetDataTbl = data;                       // export data into enclosing scope
    var x     = d3.scale.linear().range([0, width]);
    var xAxis = d3.svg.axis().scale(x).orient("bottom");
    x.domain(d3.extent(data, function(d) { return d.oneYrRisk; })).nice();

    var y     = d3.scale.linear().range([height, 0]);
    var yAxis = d3.svg.axis().scale(y).orient("left");
    y.domain(d3.extent(data, function(d) { return d.oneYrReturn; })).nice();

    var hypb     = d3.scale.linear().range([height, 0]);
    var hypbAxis = d3.svg.axis().scale(hypb).orient("right");
    hypb.domain(d3.extent(data, function(d) { return d.oneYrReturn; })).nice();
                               
    var color = d3.scale.category10();

    var svg = d3.select("body").append("svg")
	.attr("width",  width  + margin.left + margin.right)
	.attr("height", height + margin.top  + margin.bottom)
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    svg.append("g").attr("class", "x axis")
	  .attr("transform", "translate(0," + height + ")")
	  .call(xAxis)
	  .append("text")
	  .attr("class", "label")
	  .attr("x", width)
	  .attr("y", -6)
	  .style("text-anchor", "end")
	  .text("1 Year Risk %");

    svg.append("g").attr("class", "y axis")
	  .call(yAxis)
	  .append("text")
	  .attr("class", "label")
	  .attr("transform", "rotate(-90)")
	  .attr("y", 6)
	  .attr("dy", ".71em")
	  .style("text-anchor", "end")
	  .text("1 Year Return %");

    svg.append("g").attr("class", "mvp_hyperbola")
	  .call(hypbAxis)
	  .append("text")
	  .attr("class", "label")
	  .attr("transform", "rotate(-90)")
	  .attr("y", 6)
	  .attr("dy", ".71em")
	  .style("text-anchor", "end")
	  .text("mvp hyperbola");
                               
// $.find("svg rect.aName")[0].__data__;
// db1.filter(function(e) {return e.pfMemb==1})
// d3.selectAll("circle").filter(function(e) {return e.pfMemb==1})

  var drag = d3.behavior.drag()
              .on("drag", function(d,i) {
			   if (d.assetId!="p") {   							      // can't stretch the 100% weight portfolio 
			     deltaWght = (d3.event.dx+d3.event.dy)/4;
			     console.log("scatterPLot:d3.behavior.drag:deltaWght:"+deltaWght);
			     pfAssetElems = d3.selectAll("circle").filter(function(e) {return e.pfMemb==1}) // get ju sthe assets in portfolio, not other objects
			     numOtherAssets = pfAssetElems[0].length-1;                                     // downweight the non-selected assest equally
			     pfAssetElems[0].forEach(function(x) {                                          // update their data 
						      sameThing = (d.assetId==x.getAttribute("myid"));      // sameThing = (x.__data__.assetId==x.getAttribute("myid")); 
						      if (sameThing) { 
							  newWght = x.__data__.assetWeight + deltaWght; 
							  x.__data__.assetWeight= Math.min(Math.max(newWght, 1), 100); 
						      } else { 
							  newWght = x.__data__.assetWeight - deltaWght/numOtherAssets; 
							  x.__data__.assetWeight = Math.min(Math.max(newWght,1), 100);
						      }  // down weight the rest equally
			     });
			     pfAssetElems.attr("r", function(dd){ return Math.sqrt(dd.assetWeight * wghtScaling)}) // update their radii

			     asstWghts = pfAssetElems[0].map(function(x) { return x.__data__.assetWeight/wghtScaling } );
			     asstRtns  = pfAssetElems[0].map(function(x) { return x.__data__.oneYrReturn             } );
			     asstRsks  = pfAssetElems[0].map(function(x) { return x.__data__.oneYrRisk               } );

			     rr = calcPfRiskEnRtn(corrMtx, asstRsks, asstRtns, asstWghts);

			     pfData = d3.select('circle.p')[0][0].__data__;
			     pfData.oneYrRisk   = rr.rsk*wghtScaling;
			     pfData.oneYrReturn = rr.rtn*wghtScaling ;
			     d3.select('circle.p')                                            		      // re-assert to trigger update
				.attr("cx", function(e) { return x(e.oneYrRisk);   })
				.attr("cy", function(e) { return y(e.oneYrReturn); });
			}
                       }
                 );

// document.querySelector("circle").__data__

  svg.selectAll(".dot")
	.data(data)
	.enter().append('circle')          								      //       circle.each(function(d) { d.element = this; }) 
          .attr("pfMemb",  function(d) { return (d.pfMemb);          })
  	  .attr("class",   function(d) { return (d.assetId);         })
  	  .attr("myid",    function(d) { return (d.assetId);         })
	  .attr("r",       function(d) { return Math.sqrt(d.assetWeight * wghtScaling); })  // use sqrt so that circle area is proportional to weight
	  .attr("cx",      function(d) { return x(d.oneYrRisk);      })
	  .attr("cy",      function(d) { return y(d.oneYrReturn);    })
	  .style("fill",   function(d) { return color(d.assetClass); })
	  .style("stroke", "grey")
	  .style("stroke-width", 2)
          .call(drag);

    var legend = svg.selectAll(".legend")
	.data(color.domain())
	.enter().append("g")
	.attr("class", "legend")
	.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

    legend.append("rect")
	.attr("x", width - 18)
	.attr("width",  18)
	.attr("height", 18)
	.style("fill", color);

    legend.append("text")
	.attr("x", width - 24)
	.attr("y", 9)
	.attr("dy", ".35em")
	.style("text-anchor", "end")
	.text(function(d) { return d; });

   });

</script>
